# #166 「メソッドデコレータの型定義、どう書く？」制作ドキュメント

## 台本
ずんだもん「メソッドデコレータの型定義、どう書く？」
四国めたん「v5.9ではメソッドデコレータはPropertyDescriptorを受け取り、メソッドの振る舞いを変更できます」
ずんだもん「ぼくはログ出力や性能測定のメソッドデコレータを作る時、型定義をしっかり書いて再利用してるんだよね」
四国めたん「メソッドデコレータの型を正しく定義すると、デコレータ内でのメソッドの型が保たれて安全です」
ずんだもん「実行時間を計測するデコレータを型付きで作ったら、どんなメソッドにも安全に適用できたんだよ！」
四国めたん「みなさんはメソッドデコレータの型定義をどう書いていますか？」
ずんだもん「実装パターンをコメントで教えてね！」

## 画面表示用コード

```typescript
// 型安全なメソッドデコレータ
function Measure(
  target: any,
  propertyKey: string,
  descriptor: PropertyDescriptor
): PropertyDescriptor {
  const originalMethod = descriptor.value;

  descriptor.value = async function(...args: any[]) {
    const start = Date.now();
    const result = await originalMethod.apply(this, args);
    const end = Date.now();
    console.log(`${propertyKey} took ${end - start}ms`);
    return result;
  };

  return descriptor;
}

class Service {
  @Measure
  async fetchData() {
    await new Promise(resolve => setTimeout(resolve, 100));
    return 'data';
  }
}
```

```typescript
// ジェネリックなメソッドデコレータ
function Log<T extends (...args: any[]) => any>(
  target: Object,
  propertyKey: string,
  descriptor: TypedPropertyDescriptor<T>
): TypedPropertyDescriptor<T> {
  const originalMethod = descriptor.value!;

  descriptor.value = function(...args: Parameters<T>): ReturnType<T> {
    console.log(`Calling ${propertyKey} with`, args);
    return originalMethod.apply(this, args);
  } as T;

  return descriptor;
}
```

## 制作メモ
- **問いの切り口**: メソッドデコレータの型定義の書き方
- **想定視聴者層**: デコレータを型安全に実装したいエンジニア
- **押さえる技術キーワード**: メソッドデコレータ, PropertyDescriptor, 型安全
- **キャラの立場**: 四国めたん=型定義の説明 / ずんだもん=実用的な実装例
- **コメントで聞きたいこと**: 型定義の実装パターン
- **補足メモ**: 性能測定という実用的な例を提示
