# #161 「インターフェースの多重実装、使ってる？」制作ドキュメント

## 台本
ずんだもん「インターフェースの多重実装、使ってる？」
四国めたん「v5.9ではインターフェースの多重実装により、複数の契約を同時に満たすクラスを作れます」
ずんだもん「ぼくは機能を小さなインターフェースに分割して、必要な機能だけを組み合わせて実装するんだよね」
四国めたん「多重実装はInterface Segregation Principleに従い、大きなインターフェースを小さな専門的なものに分割できます」
ずんだもん「ログ機能、シリアライズ機能、バリデーション機能を別々のインターフェースにしたら、クラスの役割が明確になったんだよ！」
四国めたん「みなさんは多重実装を活用していますか？」
ずんだもん「設計パターンや経験をコメントで教えてね！」

## 画面表示用コード

```typescript
// 小さなインターフェースに分割
interface Loggable {
  log(message: string): void;
}

interface Serializable {
  serialize(): string;
  deserialize(data: string): void;
}

interface Validatable {
  validate(): boolean;
}

// 必要な機能だけを組み合わせる
class User implements Loggable, Serializable, Validatable {
  constructor(public name: string, public email: string) {}

  log(message: string): void {
    console.log(`[User ${this.name}] ${message}`);
  }

  serialize(): string {
    return JSON.stringify({ name: this.name, email: this.email });
  }

  deserialize(data: string): void {
    const obj = JSON.parse(data);
    this.name = obj.name;
    this.email = obj.email;
  }

  validate(): boolean {
    return this.email.includes('@');
  }
}
```

```typescript
// クラスによって異なる組み合わせ
class Config implements Serializable {
  serialize(): string { return ''; }
  deserialize(data: string): void { }
  // Loggable は実装しない
}

class Service implements Loggable {
  log(message: string): void { console.log(message); }
  // Serializable は実装しない
}
```

## 制作メモ
- **問いの切り口**: インターフェースの多重実装の活用
- **想定視聴者層**: SOLID原則を意識するエンジニア
- **押さえる技術キーワード**: 多重実装, Interface Segregation, 関心の分離
- **キャラの立場**: 四国めたん=設計原則解説 / ずんだもん=小さなインターフェースの利点
- **コメントで聞きたいこと**: 活用状況や設計パターン
- **補足メモ**: Interface Segregation Principleの実践例を提示
