# #156 「`#private`フィールド、使ってる？」制作ドキュメント

## 台本
ずんだもん「`#private`フィールド、使ってる？」
四国めたん「v5.9ではES2022の`#private`フィールドがサポートされ、実行時にも真にプライベートなフィールドが作れます」
ずんだもん「ぼくは本当に隠したいデータには`#`を使って、型チェックだけでいい場合は`private`を使い分けてるんだよね」
四国めたん「`#private`フィールドは実行時にも外部からアクセスできず、より強固なカプセル化が実現できます」
ずんだもん「セキュリティが重要なクラスで`#private`を使ったら、予期しないアクセスを完全に防げたんだよ！」
四国めたん「みなさんは`#private`フィールドを使っていますか？」
ずんだもん「使い分けのルールや経験をコメントで教えてね！」

## 画面表示用コード

```typescript
// #privateフィールドの使用
class AuthService {
  #apiKey: string;
  #secretToken: string;

  constructor(apiKey: string, secretToken: string) {
    this.#apiKey = apiKey;
    this.#secretToken = secretToken;
  }

  async authenticate(user: string): Promise<boolean> {
    // 内部でのみ使用可能
    const headers = {
      'X-API-Key': this.#apiKey,
      'X-Secret': this.#secretToken
    };
    // ...
  }
}

const auth = new AuthService('key123', 'secret456');
// auth.#apiKey; // SyntaxError: 実行時エラー
```

```typescript
// privateと#privateの使い分け
class User {
  // 型チェックのみ（テストでアクセスすることもある）
  private internalId: string;

  // 実行時も完全に隠す（絶対にアクセスさせたくない）
  #passwordHash: string;

  // 公開
  public name: string;

  constructor(id: string, password: string, name: string) {
    this.internalId = id;
    this.#passwordHash = this.hashPassword(password);
    this.name = name;
  }

  private hashPassword(password: string): string {
    // パスワードのハッシュ化
    return password; // 簡略化
  }
}
```

```typescript
// #privateメソッド
class Calculator {
  #validateNumber(n: number): boolean {
    return !isNaN(n) && isFinite(n);
  }

  add(a: number, b: number): number {
    if (!this.#validateNumber(a) || !this.#validateNumber(b)) {
      throw new Error('Invalid numbers');
    }
    return a + b;
  }
}
```

## 制作メモ
- **問いの切り口**: #privateフィールドの使用状況
- **想定視聴者層**: 真のカプセル化を実現したいエンジニア
- **押さえる技術キーワード**: #private, ES2022, 実行時保護, カプセル化
- **キャラの立場**: 四国めたん=機能の特徴解説 / ずんだもん=使い分けと実用例
- **コメントで聞きたいこと**: 使用状況や使い分けルール
- **補足メモ**: privateと#privateの使い分け基準を明確に提示
