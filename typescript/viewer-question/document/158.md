# #158 「クラス継承の型安全、どう保ってる？」制作ドキュメント

## 台本
ずんだもん「クラス継承の型安全、どう保ってる？」
四国めたん「v5.9では`noImplicitOverride`オプションなどで、継承時の型安全性が向上しています」
ずんだもん「ぼくは基底クラスのメソッドをオーバーライドする時、`override`キーワードを必ず付けて意図を明示するんだよね」
四国めたん「`override`キーワードを使うと、意図しないメソッド名のtypoや、基底クラスの変更による影響を検出できます」
ずんだもん「基底クラスのメソッド名が変わった時、`override`のおかげでコンパイルエラーで気づけて助かったんだよ！」
四国めたん「みなさんはクラス継承の型安全性をどう保っていますか？」
ずんだもん「工夫やベストプラクティスをコメントで教えてね！」

## 画面表示用コード

```typescript
// overrideキーワードで意図を明示
class BaseService {
  initialize(): void {
    console.log('Base initialization');
  }

  process(data: string): void {
    console.log('Processing:', data);
  }
}

class ExtendedService extends BaseService {
  override initialize(): void {
    super.initialize();
    console.log('Extended initialization');
  }

  // typoがあると検出される
  // override proces(data: string): void { // Error: 基底クラスにメソッドが存在しない
  //   console.log('Processing:', data);
  // }
}
```

```typescript
// noImplicitOverride オプション
// tsconfig.json: "noImplicitOverride": true
class Service extends BaseService {
  // overrideキーワードが必須になる
  override process(data: string): void {
    // ...
  }

  // overrideなしでオーバーライドするとエラー
  // initialize(): void { // Error: overrideキーワードが必要
  //   // ...
  // }
}
```

```typescript
// 抽象クラスで型を強制
abstract class Repository<T> {
  abstract findById(id: string): Promise<T | null>;
  abstract save(entity: T): Promise<void>;
}

class UserRepository extends Repository<User> {
  // 実装が強制される（型安全）
  async findById(id: string): Promise<User | null> {
    // ...
  }

  async save(entity: User): Promise<void> {
    // ...
  }
}
```

## 制作メモ
- **問いの切り口**: クラス継承の型安全性維持
- **想定視聴者層**: クラス継承を安全に行いたいエンジニア
- **押さえる技術キーワード**: override, noImplicitOverride, 継承, 型安全性
- **キャラの立場**: 四国めたん=機能とオプション解説 / ずんだもん=実践的な効果体験
- **コメントで聞きたいこと**: 型安全性を保つ工夫やベストプラクティス
- **補足メモ**: overrideキーワードの実用的な効果を強調
