# #146 「`[T] extends [U]`のブラケット技、知ってた？」制作ドキュメント

## 台本
ずんだもん「`[T] extends [U]`のブラケット技、知ってた？」
四国めたん「v5.9ではこのタプル技法は分配制御の定番パターンで、高度な型操作で頻繁に使われます」
ずんだもん「ぼくは最初このパターンを見た時、なぜブラケットが必要なのか理解するのに時間がかかったんだよね」
四国めたん「ブラケットで囲むことで、TypeScriptに型を分配せず一つの単位として扱うよう指示します」
ずんだもん「ライブラリの型定義を読んでて、このパターンの意味が分かったら色々な型が理解できるようになったんだよ！」
四国めたん「みなさんはこのブラケット技を知っていましたか？」
ずんだもん「知ったきっかけや使い方をコメントで教えてね！」

## 画面表示用コード

```typescript
// ブラケットなし（分配される）
type Test1<T> = T extends string ? true : false;
type Result1 = Test1<'a' | 'b'>; // true（分配される）

// ブラケットあり（分配されない）
type Test2<T> = [T] extends [string] ? true : false;
type Result2 = Test2<'a' | 'b'>; // true（ユニオン全体を評価）
type Result3 = Test2<'a' | number>; // false（ユニオンに非stringが含まれる）
```

```typescript
// 実用例: 厳密な等価性チェック
type IsExact<T, U> = [T] extends [U]
  ? [U] extends [T]
    ? true
    : false
  : false;

type Test3 = IsExact<string, string>; // true
type Test4 = IsExact<string, string | number>; // false
type Test5 = IsExact<string | number, string>; // false
```

```typescript
// ライブラリでよく見るパターン
type UnionToIntersection<U> = (
  U extends any ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never;

// このような高度な型でもブラケット技が使われる
type NonDistributive<T> = [T] extends [any] ? T : never;
```

## 制作メモ
- **問いの切り口**: [T] extends [U]パターンの認知度
- **想定視聴者層**: 型定義を深く理解したいエンジニア
- **押さえる技術キーワード**: タプル技法, 分配制御, [T] extends [U], 型操作
- **キャラの立場**: 四国めたん=パターンの意味解説 / ずんだもん=理解の過程共有
- **コメントで聞きたいこと**: 認知のきっかけや使い方
- **補足メモ**: 分配の有無による挙動の違いを具体例で明示
