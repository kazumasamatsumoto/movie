# #136 「`Readonly<T>`のネスト対応、どうしてる？」制作ドキュメント

## 台本
ずんだもん「`Readonly<T>`のネスト対応、どうしてる？」
四国めたん「v5.9では`Readonly<T>`は浅いreadonlyのみなので、深いネストには`DeepReadonly`型を自作する必要があります」
ずんだもん「ぼくは再帰的な`DeepReadonly`型をユーティリティ型として定義して、ネストしたオブジェクトも完全にreadonlyにしてるんだよね」
四国めたん「`DeepReadonly`型は、オブジェクトのすべてのプロパティを再帰的にreadonlyにする条件型です」
ずんだもん「複雑な設定オブジェクトを`DeepReadonly`で型付けしたら、深い階層での変更も防げて安心だったんだよ！」
四国めたん「みなさんは`Readonly`のネスト対応をどうしていますか？」
ずんだもん「実装パターンや工夫をコメントで教えてね！」

## 画面表示用コード

```typescript
// Readonly<T>は浅いreadonlyのみ
type Config = Readonly<{
  database: {
    host: string;
    port: number;
  };
}>;

const config: Config = { database: { host: 'localhost', port: 5432 } };
// config.database = {}; // Error
config.database.host = 'new'; // OK（ネストは変更可能）
```

```typescript
// DeepReadonly型の実装
type DeepReadonly<T> = T extends (infer R)[]
  ? ReadonlyArray<DeepReadonly<R>>
  : T extends Function
  ? T
  : T extends object
  ? { readonly [P in keyof T]: DeepReadonly<T[P]> }
  : T;

type DeepConfig = DeepReadonly<{
  database: {
    host: string;
    port: number;
  };
}>;

const config2: DeepConfig = { database: { host: 'localhost', port: 5432 } };
// config2.database.host = 'new'; // Error（深い階層もreadonly）
```

```typescript
// type-fest などのライブラリを使う方法
import type { ReadonlyDeep } from 'type-fest';

type Config = ReadonlyDeep<{
  database: { host: string; port: number };
}>;
```

## 制作メモ
- **問いの切り口**: Readonlyのネスト対応方法
- **想定視聴者層**: 深いオブジェクト構造を扱うエンジニア
- **押さえる技術キーワード**: Readonly, DeepReadonly, 再帰的条件型, ネスト
- **キャラの立場**: 四国めたん=型の限界と解決策解説 / ずんだもん=実装パターン紹介
- **コメントで聞きたいこと**: ネスト対応の実装パターンや工夫
- **補足メモ**: 自作実装とライブラリ利用の両方の選択肢を提示
