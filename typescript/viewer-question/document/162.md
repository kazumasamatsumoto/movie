# #162 「`extends`と`implements`の併用、どう設計する？」制作ドキュメント

## 台本
ずんだもん「`extends`と`implements`の併用、どう設計する？」
四国めたん「v5.9ではクラス継承とインターフェース実装を併用でき、実装の再利用と契約の保証を両立できます」
ずんだもん「ぼくは共通実装は基底クラスから継承して、追加の契約はインターフェースで実装するんだよね」
四国めたん「`extends`で実装を継承し、`implements`で追加の契約を保証することで、柔軟な設計が可能です」
ずんだもん「リポジトリクラスで基底から共通処理を継承しつつ、キャッシュ機能をインターフェースで追加できたんだよ！」
四国めたん「みなさんは`extends`と`implements`をどう併用していますか？」
ずんだもん「設計パターンをコメントで教えてね！」

## 画面表示用コード

```typescript
// 基底クラスで共通実装
abstract class BaseRepository<T> {
  protected async query(sql: string): Promise<any[]> {
    // 共通のデータベース処理
    return [];
  }

  abstract findById(id: string): Promise<T | null>;
}

// 追加機能のインターフェース
interface Cacheable {
  clearCache(): void;
  getCacheKey(id: string): string;
}

// 継承と実装を併用
class CachedUserRepository extends BaseRepository<User> implements Cacheable {
  private cache = new Map<string, User>();

  // BaseRepositoryから継承したqueryを使用
  async findById(id: string): Promise<User | null> {
    const cacheKey = this.getCacheKey(id);
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey)!;
    }

    const rows = await this.query(`SELECT * FROM users WHERE id = ?`);
    const user = rows[0] || null;
    if (user) {
      this.cache.set(cacheKey, user);
    }
    return user;
  }

  // Cacheableインターフェースの実装
  clearCache(): void {
    this.cache.clear();
  }

  getCacheKey(id: string): string {
    return `user:${id}`;
  }
}
```

```typescript
// 複数のインターフェースと継承の組み合わせ
class AdvancedRepository extends BaseRepository<User>
  implements Cacheable, Loggable {
  // 基底クラス + 複数のインターフェース
}
```

## 制作メモ
- **問いの切り口**: extendsとimplementsの併用設計
- **想定視聴者層**: 柔軟なクラス設計を求めるエンジニア
- **押さえる技術キーワード**: extends, implements, 継承, 実装, 契約
- **キャラの立場**: 四国めたん=併用の利点解説 / ずんだもん=実用的な設計例
- **コメントで聞きたいこと**: 併用の設計パターン
- **補足メモ**: リポジトリパターンでの実践例を提示
