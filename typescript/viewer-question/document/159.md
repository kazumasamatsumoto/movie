# #159 「`abstract class`派？`interface`派？」制作ドキュメント

## 台本
ずんだもん「`abstract class`派？`interface`派？」
四国めたん「v5.9では両者は用途が異なり、実装の共有なら`abstract class`、型定義のみなら`interface`が適しています」
ずんだもん「ぼくは共通の実装ロジックがある場合は`abstract class`、純粋な契約定義には`interface`を使い分けてるんだよね」
四国めたん「`abstract class`はメソッドの実装を持てますが、多重継承できず、`interface`は型定義のみで多重実装が可能です」
ずんだもん「リポジトリパターンで、共通の基本実装を`abstract class`にしたら、コードの重複が減って保守性が上がったんだよ！」
四国めたん「みなさんは`abstract class`と`interface`をどう使い分けていますか？」
ずんだもん「使い分けの基準をコメントで教えてね！」

## 画面表示用コード

```typescript
// interface: 純粋な契約定義（実装なし）
interface Logger {
  log(message: string): void;
  error(message: string): void;
}

class ConsoleLogger implements Logger {
  log(message: string): void {
    console.log(message);
  }

  error(message: string): void {
    console.error(message);
  }
}
```

```typescript
// abstract class: 共通実装を含む
abstract class BaseRepository<T> {
  // 共通の実装
  protected async query(sql: string): Promise<any[]> {
    // データベース接続などの共通処理
    return [];
  }

  // サブクラスで実装を強制
  abstract findById(id: string): Promise<T | null>;
  abstract save(entity: T): Promise<void>;
}

class UserRepository extends BaseRepository<User> {
  // 共通のqueryメソッドを使える
  async findById(id: string): Promise<User | null> {
    const rows = await this.query(`SELECT * FROM users WHERE id = ?`);
    return rows[0] || null;
  }

  async save(entity: User): Promise<void> {
    await this.query(`INSERT INTO users ...`);
  }
}
```

```typescript
// interfaceは多重実装可能
interface Loggable {
  log(): void;
}

interface Serializable {
  serialize(): string;
}

class User implements Loggable, Serializable {
  log(): void { /* ... */ }
  serialize(): string { return JSON.stringify(this); }
}
```

## 制作メモ
- **問いの切り口**: abstract classとinterfaceの使い分け
- **想定視聴者層**: クラス設計を考えるエンジニア
- **押さえる技術キーワード**: abstract class, interface, 継承, 実装, 多重実装
- **キャラの立場**: 四国めたん=両者の違いと用途解説 / ずんだもん=実装共有の利点
- **コメントで聞きたいこと**: 使い分けの基準
- **補足メモ**: 実装の有無と多重性という明確な違いを提示
