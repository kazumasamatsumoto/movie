# #520「網羅性まとめ」

四国めたん「網羅性チェックについてまとめましょう！」
ずんだもん「網羅性チェックの重要ポイントを教えて！」
四国めたん「never型で全ケースの処理を保証します。判別Union型とassertNever関数を使いますね」
ずんだもん「どんなメリットがあるの？」
四国めたん「リファクタリングの安全性向上、バグの早期発見、保守性の改善。型システムが強力な味方ですね」
ずんだもん「なるほど！型で安全性を保証するんだね！」
四国めたん「必ずdefault/else節を書き、strictモードを有効にします。Redux、イベント処理、状態管理で活用しましょう。TypeScript v5.9でも最重要パターンですね」
ずんだもん「型安全なコードが書けるようになったよ！」

---

## 📺 画面表示用コード

```typescript
// 網羅性チェックの基本パターン
type Action = "create" | "read" | "update" | "delete";

function performAction(action: Action): void {
  switch (action) {
    case "create": /* 処理 */ break;
    case "read": /* 処理 */ break;
    case "update": /* 処理 */ break;
    case "delete": /* 処理 */ break;
    default: assertNever(action);  // 網羅性保証
  }
}
```

```typescript
// 判別Union型パターン
type Result<T> =
  | { status: "success"; data: T }
  | { status: "error"; error: Error };

function handle<T>(result: Result<T>): T {
  switch (result.status) {
    case "success": return result.data;
    case "error": throw result.error;
    default: return assertNever(result);
  }
}
```

```typescript
// assertNever関数
function assertNever(value: never): never {
  throw new Error(`Unexpected value: ${value}`);
}

// 使用例：型を追加したら自動的に型エラーになる
type Status = "idle" | "loading" | "success" | "error";
// 新しいステータスを追加すると、
// すべての switch文 で型エラーが発生
```
