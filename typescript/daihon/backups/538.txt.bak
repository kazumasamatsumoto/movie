# #538 「Nest.js例外フィルタ」

四国めたん「Nest.jsの例外フィルタとnever型について学びましょう！」
ずんだもん「例外フィルタでnever型をどう使うの？」
四国めたん「すべての例外タイプを網羅的に処理し、未処理の例外をnever型で検出できます」
ずんだもん「具体的にどう実装するの？」
四国めたん「判別Union型で例外を定義し、catchメソッドで網羅的にハンドリングしますね」
ずんだもん「なるほど！例外処理の漏れを防げるんだね！」
四国めたん「型安全な例外ハンドリングにより、エラー対応の品質が向上しますね」
ずんだもん「マイクロサービスでの信頼性が上がるよ！」

---

## 📺 画面表示用コード

```typescript
// 例外タイプの定義
type AppException =
  | { type: 'validation'; errors: string[] }
  | { type: 'unauthorized'; message: string }
  | { type: 'notfound'; resource: string };

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: AppException, host: ArgumentsHost) {
    if (exception.type === 'validation') return this.handleValidation(exception);
    if (exception.type === 'unauthorized') return this.handleUnauth(exception);
    if (exception.type === 'notfound') return this.handleNotFound(exception);
    const check: never = exception;
  }
}
```

```typescript
// HTTPステータスの網羅的処理
type HttpError = 400 | 401 | 403 | 404 | 500;

function getErrorMessage(status: HttpError): string {
  if (status === 400) return 'Bad Request';
  if (status === 401) return 'Unauthorized';
  if (status === 403) return 'Forbidden';
  if (status === 404) return 'Not Found';
  if (status === 500) return 'Internal Server Error';
  const check: never = status;
  return 'Unknown Error';
}
```

```typescript
// カスタム例外フィルタ
type DomainException =
  | { domain: 'user'; code: 'NOT_FOUND' | 'DUPLICATE' }
  | { domain: 'order'; code: 'INVALID' | 'EXPIRED' };

function handleException(ex: DomainException): HttpException {
  if (ex.domain === 'user') return new BadRequestException(ex.code);
  if (ex.domain === 'order') return new UnprocessableEntityException(ex.code);
  const check: never = ex;
  throw new InternalServerErrorException();
}
```
