# #549 「ベストプラクティス」

四国めたん「never型のベストプラクティスについて学びましょう！」
ずんだもん「どう使うのがベストなの？」
四国めたん「exhaustiveCheck関数の統一、判別Union型の活用、型ガードの徹底が重要です」
ずんだもん「具体的なガイドラインを教えて！」
四国めたん「プロジェクト全体で共通のヘルパー関数を定義し、すべての分岐で網羅性をチェックしますね」
ずんだもん「なるほど！チーム全体で統一できるんだね！」
四国めたん「ESLintルールと組み合わせることで、さらに品質が向上しますね」
ずんだもん「型安全な開発文化を作るよ！」

---

## 📺 画面表示用コード

```typescript
// ベストプラクティス1: 共通ヘルパー
// utils/exhaustive.ts
export function exhaustiveCheck(value: never, context?: string): never {
  const msg = context
    ? `Unhandled case in ${context}: ${JSON.stringify(value)}`
    : `Unhandled case: ${JSON.stringify(value)}`;
  throw new Error(msg);
}

export function assertNever(value: never): never {
  throw new Error(`Unexpected value: ${value}`);
}
```

```typescript
// ベストプラクティス2: 判別Union型
type Result<T, E> =
  | { success: true; value: T }
  | { success: false; error: E };

type DomainEvent =
  | { type: 'UserCreated'; userId: string }
  | { type: 'UserUpdated'; userId: string; data: any };

// 必ず判別プロパティ（type, kind, success等）を持たせる
```

```typescript
// ベストプラクティス3: すべての分岐で網羅性チェック
function handleEvent(event: DomainEvent): void {
  switch (event.type) {
    case 'UserCreated':
      return this.onCreate(event);
    case 'UserUpdated':
      return this.onUpdate(event);
    default:
      return exhaustiveCheck(event, 'handleEvent');
  }
}
```
