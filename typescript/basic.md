# 📘 TypeScript基礎からジェネリクス300本 完全タイトル一覧

反復学習で確実に身につく！同じテーマを様々な角度から学ぶ構成です。

## 🎯 第1章: プリミティブ型の完全理解（50本）

### **string型（12本）**
1. string型の基本 - 文字列に型をつける第一歩
2. テンプレートリテラルとstring型 - 変数埋め込みの型安全性
3. 複数行文字列とstring型 - バッククォートの活用
4. stringとString型の決定的な違い - プリミティブvsラッパー
5. 文字列結合と型推論 - TypeScriptが自動で型を判断
6. stringリテラル型との違い - 「任意の文字列」vs「特定の文字列」
7. string型とany型の危険な違い - 型安全性の重要性
8. オプショナルなstring型 - 値がないかもしれない文字列
9. nullableなstring型 - nullを許可する文字列型
10. readonlyなstring変数 - 再代入を防ぐconst
11. string型のメソッドと型推論 - toUpperCase()の戻り値型
12. string型の配列 - string[]とArray<string>

### **number型（12本）**
13. number型の基本 - 数値に型をつける
14. 整数と小数の扱い - TypeScriptでは区別なし
15. 浮動小数点数とnumber型 - 小数の型安全性
16. 特殊な数値 - Infinity, -Infinity, NaN
17. 2進数・8進数・16進数とnumber型 - 様々な表記法
18. 数値リテラル型 - 特定の数値のみを許可
19. 数値計算と型推論 - 演算結果の型は？
20. Numberとnumberの違い - プリミティブvsラッパー
21. 数値範囲のチェックと型 - バリデーション関数の型
22. オプショナルなnumber型 - デフォルト値のある引数
23. number型と算術演算子 - 四則演算の型推論
24. number型のメソッド - toFixed()とtoString()

### **boolean型（10本）**
25. boolean型の基本 - true/falseに型をつける
26. 論理演算と型推論 - &&, ||, !の結果型
27. 比較演算子と型推論 - ===, !==の戻り値
28. booleanリテラル型 - trueのみ、falseのみの型
29. 型ガード関数とboolean - is演算子との組み合わせ
30. 三項演算子と型推論 - 条件分岐の結果型
31. 論理否定演算子 - !による型の扱い
32. 短絡評価とboolean型 - &&と||の型推論
33. Boolean関数の罠 - 思わぬtruthyとfalsy
34. booleanの暗黙的型変換 - !!による型変換

### **null/undefined（8本）**
35. nullとundefinedの基本 - 「値がない」を表す2つの型
36. nullとundefinedの使い分け - 明示的な空vs未定義
37. strictNullChecksの威力 - 型安全性を最大化
38. nullable型の定義 - | nullで値を許可
39. オプショナル型とundefined - ?の本当の意味
40. Non-null assertion operator - !で型を断言（危険）
41. Nullish coalescing演算子 - ??でデフォルト値
42. Optional chaining - ?.で安全なプロパティアクセス

### **その他のプリミティブ型（8本）**
43. void型の意味 - 「戻り値なし」を表す型
44. never型の基本 - 「到達しない」を表す型
45. unknown型 - anyより安全な「不明な型」
46. any型の危険性 - 型安全性を失う最後の手段
47. symbol型の基本 - 一意な値を作る
48. bigint型 - 巨大な整数を扱う
49. プリミティブ型の型変換 - Number(), String(), Boolean()
50. typeof演算子 - 実行時の型チェック

## 🔧 第2章: 配列型の完全マスター（30本）

### **配列型の基本（10本）**
51. 配列型の基本 - Array<T>記法
52. 配列型の基本 - T[]記法
53. Array<T>とT[]の使い分け - どちらを使うべき？
54. 空配列の型推論 - []の型は？
55. 配列リテラルと型推論 - 要素から型を推論
56. 混合型配列 - 複数の型を含む配列
57. 配列の要素アクセスと型 - インデックスアクセスの型
58. 配列メソッドと型推論 - map, filter, reduceの型
59. 配列の分割代入と型 - destructuringの型推論
60. スプレッド構文と配列型 - ...の型の扱い

### **readonly配列（5本）**
61. readonly配列の基本 - 変更不可の配列
62. ReadonlyArray<T>型 - 組み込み型の活用
63. readonly配列と通常配列の互換性 - 代入の可否
64. as constで配列をreadonlyに - リテラル型の固定
65. readonly配列とメソッド - 変更メソッドが使えない

### **多次元配列とタプル（8本）**
66. 多次元配列の型 - number[][]の意味
67. 3次元配列の型定義 - より深い配列
68. タプル型の基本 - 固定長の配列
69. タプル型と配列型の違い - 長さと型の違い
70. オプショナル要素のタプル - ?付きタプル
71. 可変長タプル - rest要素のあるタプル
72. ラベル付きタプル - 要素に名前をつける
73. タプルの分割代入 - 型安全な取り出し

### **配列の応用パターン（7本）**
74. 配列のUnion型 - (string | number)[]の意味
75. Union型の配列 - string[] | number[]との違い
76. 配列の型ガード - Array.isArray()の活用
77. ジェネリック配列関数の基本 - <T>[]の関数
78. 配列のフィルタリングと型 - filter後の型
79. 配列の変換と型 - mapによる型変換
80. 配列のリデュースと型 - reduceの戻り値型

## 📦 第3章: オブジェクト型の深掘り（30本）

### **オブジェクト型の基本（10本）**
81. オブジェクト型の基本 - {key: type}記法
82. プロパティの型指定 - 各プロパティに型をつける
83. オブジェクトリテラルと型推論 - TypeScriptが型を推論
84. ネストしたオブジェクト型 - オブジェクトの中のオブジェクト
85. オプショナルプロパティ - ?で省略可能に
86. readonlyプロパティ - 変更不可のプロパティ
87. オブジェクトの分割代入と型 - destructuringの型
88. スプレッド構文とオブジェクト型 - ...での結合
89. オブジェクトのコピーと型 - シャローコピーの型
90. computed propertyと型 - [key]での動的プロパティ

### **インデックス署名（5本）**
91. インデックス署名の基本 - [key: string]: type
92. 文字列インデックス署名 - 任意の文字列キー
93. 数値インデックス署名 - 配列的なオブジェクト
94. インデックス署名と通常プロパティの組み合わせ
95. Record型 - インデックス署名の便利な書き方

### **型エイリアスとインターフェース（8本）**
96. 型エイリアス(type)の基本 - 型に名前をつける
97. インターフェース(interface)の基本 - オブジェクト型の定義
98. typeとinterfaceの違い(1) - 拡張方法の違い
99. typeとinterfaceの違い(2) - Union型の扱い
100. typeとinterfaceの使い分け - どちらを使うべき？
101. インターフェースの継承 - extendsで型を拡張
102. 型エイリアスの交差 - &で型を合成
103. インターフェースのマージ - 同名interfaceの結合

### **オブジェクトの応用（7本）**
104. オブジェクトのUnion型 - {a: string} | {b: number}
105. オブジェクトのIntersection型 - {a: string} & {b: number}
106. 過剰プロパティチェック - 余分なプロパティの検出
107. オブジェクトの型ガード - in演算子の活用
108. オブジェクトの型変換 - asによるアサーション
109. Partial<T> - 全プロパティをオプショナルに
110. Required<T> - 全プロパティを必須に

## ⚙️ 第4章: 関数型の完全習得（25本）

### **関数型の基本（10本）**
111. 関数の型注釈 - 引数と戻り値の型
112. 関数式の型 - アロー関数の型注釈
113. 関数型の型エイリアス - 関数型に名前をつける
114. オプショナル引数 - ?付き引数
115. デフォルト引数と型推論 - =でデフォルト値
116. rest引数と型 - ...argsの型
117. 戻り値の型推論 - returnから型を推論
118. void型の関数 - 戻り値なしの関数
119. never型を返す関数 - 絶対に返らない関数
120. thisの型注釈 - thisパラメータの型

### **関数オーバーロード（5本）**
121. 関数オーバーロードの基本 - 複数のシグネチャ
122. オーバーロードと型推論 - 引数から戻り値を推論
123. オーバーロードの順序 - 具体的な型を先に
124. オーバーロードvs Union型 - どちらを使うべき？
125. オーバーロードの実装 - 実装シグネチャの書き方

### **高階関数と型（10本）**
126. 高階関数の型 - 関数を返す関数
127. コールバック関数の型 - 引数として渡す関数
128. 関数型の引数 - (callback: () => void) => void
129. ジェネリック関数の予告 - <T>の導入前夜
130. map関数の型 - Array<T>からArray<U>へ
131. filter関数の型 - 型の絞り込み
132. reduce関数の型 - アキュムレータの型
133. forEach関数の型 - void型の関数
134. クロージャと型 - 外側の変数の型
135. カリー化関数の型 - 部分適用の型

## 🔀 第5章: Union型の完全理解（20本）

### **Union型の基本（8本）**
136. Union型の基本 - | で複数の型を許可
137. 2つの型のUnion - string | number
138. 3つ以上の型のUnion - string | number | boolean
139. Union型と型推論 - 変数代入時の型
140. Union型の変数への代入 - どの型でもOK
141. Union型とメソッド - 共通メソッドのみ使える
142. Union型と型エイリアス - 複雑なUnionに名前を
143. nullableなUnion型 - T | null | undefined

### **Union型の絞り込み（7本）**
144. typeof型ガードでUnion型を絞り込み(1) - string判定
145. typeof型ガードでUnion型を絞り込み(2) - number判定
146. 等価性チェックで絞り込み - === での型判定
147. truthyチェックで絞り込み - ifでの型の変化
148. in演算子で絞り込み - プロパティ存在チェック
149. instanceof演算子で絞り込み - クラスインスタンス判定
150. Union型の絞り込みパターン総まとめ

### **判別Union型（5本）**
151. 判別Union型の基本 - タグ付きUnion
152. type プロパティで判別 - 共通プロパティの活用
153. kind プロパティで判別 - 別名でのタグ付け
154. 判別Union型のswitch文 - 網羅性チェック
155. 判別Union型のベストプラクティス

## ✖️ 第6章: Intersection型の理解（15本）

### **Intersection型の基本（8本）**
156. Intersection型の基本 - &で型を合成
157. 2つの型のIntersection - 両方の型を満たす
158. Intersection型と型エイリアス - 複雑な型に名前を
159. IntersectionとUnionの違い - &と|の違い
160. オブジェクト型のIntersection - プロパティのマージ
161. Intersectionとインターフェース継承の違い
162. プリミティブ型のIntersection - never型になる場合
163. Intersection型のユースケース - ミックスイン

### **Intersection型の応用（7本）**
164. Intersection型で型を拡張 - 既存型に追加
165. Intersection型とジェネリクス - <T> & {id: string}
166. 複数のIntersection - A & B & C
167. Intersection型の順序 - 順番は関係ない
168. Intersection型と関数 - 複数の関数シグネチャ
169. Intersection型とUnion型の組み合わせ
170. Intersection型のベストプラクティス

## 💎 第7章: リテラル型の活用（15本）

### **リテラル型の基本（8本）**
171. 文字列リテラル型 - 特定の文字列のみ許可
172. 数値リテラル型 - 特定の数値のみ許可
173. booleanリテラル型 - trueまたはfalse
174. リテラル型とプリミティブ型の違い
175. リテラル型のUnion - 複数のリテラルを許可
176. リテラル型と型推論 - letとconstの違い
177. as constでリテラル型に - 型の固定
178. const assertionの威力 - オブジェクト全体を固定

### **リテラル型の応用（7本）**
179. リテラル型でステータス管理 - "success" | "error"
180. リテラル型でイベント名 - "click" | "scroll"
181. リテラル型で設定値 - "development" | "production"
182. テンプレートリテラル型への予告
183. リテラル型と判別Union - type: "A" | "B"
184. リテラル型のナローイング - 型の絞り込み
185. リテラル型のベストプラクティス

## 🏷️ 第8章: 型エイリアスとインターフェース再訪（20本）

### **型エイリアス深堀り（10本）**
186. 型エイリアスの基本おさらい - type User = ...
187. 型エイリアスでUnion型 - type ID = string | number
188. 型エイリアスでIntersection型 - type A = B & C
189. 型エイリアスでタプル - type Point = [number, number]
190. 型エイリアスで関数型 - type Callback = () => void
191. ネストした型エイリアス - 型の中に型
192. 型エイリアスの再帰的定義 - 自分自身を参照
193. 型エイリアスとジェネリクスの予告
194. 型エイリアスの命名規則 - PascalCase
195. 型エイリアスのベストプラクティス

### **インターフェース深堀り（10本）**
196. インターフェースの基本おさらい - interface User {}
197. インターフェースの継承 - extends での拡張
198. 複数のインターフェース継承 - A extends B, C
199. インターフェースの実装 - classとimplements
200. インターフェースのマージ - 宣言の統合
201. インターフェースとreadonly - 不変プロパティ
202. インターフェースとオプショナル - ?付きプロパティ
203. インターフェースとメソッド - 関数プロパティ
204. インターフェースとコンストラクタシグネチャ
205. インターフェースのベストプラクティス

## 🧠 第9章: 型推論の完全理解（20本）

### **型推論の基本（10本）**
206. 型推論とは - TypeScriptが型を自動判定
207. 変数宣言と型推論 - let x = 1の型は？
208. const宣言と型推論 - リテラル型になる
209. 配列リテラルと型推論 - [1, 2, 3]の型
210. オブジェクトリテラルと型推論 - {x: 1}の型
211. 関数の戻り値と型推論 - returnから推論
212. 関数の引数と型推論 - デフォルト値から推論
213. 文脈的型推論 - Contextual Typing
214. Best Common Type - 最適共通型の選択
215. 型推論の限界 - 明示的な型注釈が必要な場面

### **型推論の応用（10本）**
216. 型推論とジェネリクス予告 - <T>が推論される
217. 型推論とUnion型 - 複数の可能性
218. 型推論と型の拡大 - Type Widening
219. 型推論と型の縮小 - Type Narrowing
220. 型推論とas const - リテラル型の固定
221. 型推論とスプレッド構文 - ...での型
222. 型推論と分割代入 - destructuringの型
223. 型推論と三項演算子 - 条件分岐の型
224. 型推論と短絡評価 - &&, ||の型
225. 型推論のベストプラクティス

## 🛡️ 第10章: 型ガードの完全マスター（20本）

### **typeof型ガード（5本）**
226. typeof型ガードの基本 - typeof x === "string"
227. typeof型ガードとUnion型 - 型の絞り込み
228. typeof型ガードの全パターン - string, number等
229. typeof型ガードとelse節 - 残りの型
230. typeof型ガードのベストプラクティス

### **in型ガード（5本）**
231. in演算子の基本 - "property" in object
232. in型ガードでオブジェクト判別
233. in型ガードと判別Union型
234. in型ガードとオプショナルプロパティ
235. in型ガードのベストプラクティス

### **instanceof型ガード（5本）**
236. instanceof演算子の基本 - obj instanceof Class
237. instanceof型ガードとクラス
238. instanceof型ガードと継承
239. instanceof型ガードとError型
240. instanceof型ガードのベストプラクティス

### **ユーザー定義型ガード（5本）**
241. 型述語の基本 - x is Type
242. ユーザー定義型ガード関数の実装
243. 型述語とUnion型の絞り込み
244. 型述語と配列のフィルタリング
245. 型述語のベストプラクティス

## 🎯 第11章: ジェネリクス基礎（25本）

### **ジェネリクスの導入（8本）**
246. ジェネリクスとは - 型の変数<T>
247. なぜジェネリクスが必要？ - any型の問題点
248. ジェネリクス関数の基本 - function identity<T>(arg: T): T
249. ジェネリクスと型推論 - <T>を省略できる
250. ジェネリクスの明示的な型指定 - identity<string>("hello")
251. 複数の型パラメータ - <T, U>
252. ジェネリクスの命名規則 - T, U, V, K
253. ジェネリクスとドキュメント - 分かりやすい命名

### **ジェネリクス関数（8本）**
254. 配列を返すジェネリクス関数 - <T> => T[]
255. 配列を受け取るジェネリクス関数 - (arr: T[]) => T
256. firstOf関数の実装 - 配列の最初の要素
257. lastOf関数の実装 - 配列の最後の要素
258. swap関数の実装 - 2つの値を入れ替え
259. map関数の実装 - 配列を変換
260. filter関数の実装 - 配列をフィルタ
261. reduce関数の型 - アキュムレータの型

### **ジェネリクスとインターフェース・型エイリアス（9本）**
262. ジェネリックインターフェースの基本 - interface Box<T>
263. ジェネリックな型エイリアス - type Box<T> = {value: T}
264. Array<T>の秘密 - 組み込みジェネリクス型
265. Promise<T>の基本 - 非同期の型
266. ジェネリックなオブジェクト型
267. ジェネリックな関数型 - type Fn<T> = (arg: T) => T
268. ジェネリックなタプル型
269. ジェネリックとネスト - Box<Box<T>>
270. ジェネリクスのデフォルト型パラメータ - <T = string>

## 🔐 第12章: ジェネリクス制約（20本）

### **extends制約の基本（8本）**
271. extends制約とは - <T extends Type>
272. オブジェクト型の制約 - <T extends {id: number}>
273. 配列型の制約 - <T extends any[]>
274. 文字列型の制約 - <T extends string>
275. 複数プロパティの制約 - extends {a: string, b: number}
276. インターフェースでの制約 - <T extends User>
277. Union型での制約 - <T extends string | number>
278. 制約と型推論の関係

### **keyof制約（7本）**
279. keyof演算子の基本 - オブジェクトのキー型
280. keyof制約 - <K extends keyof T>
281. プロパティアクセスの型安全化
282. getProperty関数の実装 - 型安全なアクセス
283. setProperty関数の実装 - 型安全な設定
284. keyof制約と文字列リテラル型
285. keyof制約のベストプラクティス

### **複雑な制約（5本）**
286. 複数の制約 - <T extends A & B>
287. 条件付き制約への予告
288. 制約とデフォルト型パラメータ
289. 制約の順序と依存関係 - <T, U extends T>
290. 制約のベストプラクティス

## 🌟 第13章: ジェネリクス応用（10本）

291. ジェネリッククラスの基本 - class Box<T>
292. ジェネリックなRepository パターン
293. ジェネリックなResult型 - 成功/失敗の型
294. ジェネリックなOption型 - Some/Noneの型
295. ジェネリックなEither型 - Left/Rightの型
296. ジェネリックなBuilder パターン
297. ジェネリックなFactory パターン
298. ジェネリクスと実践的な型設計
299. ジェネリクスのパフォーマンス考慮
300. ジェネリクスマスターへの道 - 次のステップ

---

## 🎓 この300本の特徴

### **反復学習の効果**
- 同じ概念を10回以上、異なる角度から学習
- 微妙な違いを比較することで本質が見える
- 実践的なコード例で即戦力に

### **段階的な難易度**
- 1-50本: 完全初心者でもOK
- 51-150本: 基礎を固める
- 151-250本: 実践力をつける
- 251-300本: ジェネリクスをマスター

### **30秒で完結**
- 1つのテーマに集中
- めたん（講師）とずんだもん（開発者）の対話
- すぐに試せる具体的なコード

この構成なら、確実に型の基礎からジェネリクスまでマスターできます！

