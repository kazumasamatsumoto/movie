# #048 「競合状態（Race Condition）」

```javascript
// race.mjs
import { Worker, isMainThread, workerData, parentPort } from 'node:worker_threads';
if (isMainThread) {
  const shared = new SharedArrayBuffer(4);
  const view = new Int32Array(shared);
  await Promise.all(
    Array.from({ length: 4 }, () => new Promise(resolve => {
      const worker = new Worker(new URL(import.meta.url), { workerData: shared });
      worker.on('exit', resolve);
    })),
  );
  console.log(`expected 400000, actual ${view[0]}`);
} else {
  const view = new Int32Array(workerData);
  for (let i = 0; i < 100_000; i += 1) {
    const tmp = view[0];
    view[0] = tmp + 1; // 非アトミックな更新で競合
  }
  parentPort?.postMessage('done');
}
```

```javascript
// safe.mjs
import { Worker, isMainThread, workerData, parentPort } from 'node:worker_threads';
if (isMainThread) {
  const shared = new SharedArrayBuffer(4);
  const view = new Int32Array(shared);
  await Promise.all(
    Array.from({ length: 4 }, () => new Promise(resolve => {
      const worker = new Worker(new URL(import.meta.url), { workerData: shared });
      worker.on('exit', resolve);
    })),
  );
  console.log(`atomically updated: ${Atomics.load(view, 0)}`);
} else {
  const view = new Int32Array(workerData);
  for (let i = 0; i < 100_000; i += 1) {
    Atomics.add(view, 0, 1);
  }
  parentPort?.postMessage('done');
}
```

```text
SharedArrayBuffer を複数スレッドで扱うときは Atomics などで整合性を確保しましょう。
```
