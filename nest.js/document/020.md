# #020 「非同期処理基礎 - Promise と async/await」

四国めたん「NestJSではPromiseとasync/awaitを前提に設計されています」
ずんだもん「非同期の扱いで気をつけるポイントは何かな？」
四国めたん「ServiceやControllerはPromiseを返してDIコンテナが解決します」
ずんだもん「awaitでエラー処理をまとめると読みやすいよ」
四国めたん「例外はHttpExceptionでラップしつつthrowしましょう」
ずんだもん「try-catchでログを挟んでおくとデバッグしやすいね」
四国めたん「Promise.allで並列化するとレスポンスを高速化できます」
ずんだもん「非同期を制御できればパフォーマンスがぐっと上がるよ！」

---

## 📺 画面表示用コード

```typescript
// user.service.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class UserService {
  async findById(id: string) {
    return { id, name: 'User' };
  }
}

// user.controller.ts
import { Controller, Get, Param } from '@nestjs/common';
import { UserService } from './user.service';

@Controller('users')
export class UserController {
  constructor(private readonly users: UserService) {}

  @Get(':id')
  async getUser(@Param('id') id: string) {
    const user = await this.users.findById(id);
    return user;
  }
}

// parallel.service.ts
import { Injectable, HttpException } from '@nestjs/common';

@Injectable()
export class ParallelService {
  async fetchAggregated(id: string) {
    try {
      const [profile, orders] = await Promise.all([
        this.loadProfile(id),
        this.loadOrders(id),
      ]);
      return { profile, orders };
    } catch (error) {
      throw new HttpException('Failed to load resources', 503, { cause: error });
    }
  }

  private loadProfile(id: string) {
    return Promise.resolve({ id, name: 'User' });
  }

  private loadOrders(id: string) {
    return Promise.resolve([{ id: 'order-1' }]);
  }
}
```
