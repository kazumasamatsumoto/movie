# #011 「Nest.jsの設計思想 - SOLID原則」

四国めたん「NestJSはSOLID原則を実践する設計思想です」
ずんだもん「各原則がどうコードに現れるのか知りたいよ」
四国めたん「SとOはControllerとServiceを分けて責務と拡張性を守ります」
ずんだもん「単一責任でテストも読みやすくなるんだね」
四国めたん「LSPとDIPは抽象Providerと依存性注入で保証します」
ずんだもん「インターフェース経由なら実装を差し替えやすいよ」
四国めたん「ISPはDTOやContractsを細かく分けて依存を最小化します」
ずんだもん「SOLIDを満たす構造が最初から整っているのが嬉しいよ！」

---

## 📺 画面表示用コード

```typescript
// user.repository.ts
export interface User {
  id: string;
  name: string;
}

export interface UserRepository {
  findById(id: string): Promise<User | null>;
  save(user: User): Promise<void>;
}

// prisma-user.repository.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma.service';

@Injectable()
export class PrismaUserRepository implements UserRepository {
  constructor(private readonly prisma: PrismaService) {}

  async findById(id: string) {
    return this.prisma.user.findUnique({ where: { id } });
  }

  async save(user: User) {
    await this.prisma.user.upsert({ where: { id: user.id }, update: user, create: user });
  }
}

// user.service.ts
import { Inject, Injectable } from '@nestjs/common';
import { UserRepository } from './user.repository';

@Injectable()
export class UserService {
  constructor(
    @Inject('UserRepository') private readonly repo: UserRepository,
  ) {}

  async getProfile(id: string) {
    const user = await this.repo.findById(id);
    return user ?? { id, name: 'Guest' };
  }
}

// user.module.ts
import { Module } from '@nestjs/common';
import { UserService } from './user.service';
import { PrismaUserRepository } from './prisma-user.repository';

@Module({
  providers: [
    UserService,
    {
      provide: 'UserRepository',
      useClass: PrismaUserRepository,
    },
  ],
  exports: [UserService],
})
export class UserModule {}
```
